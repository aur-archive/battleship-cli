#!/bin/bash

# Морской бой
tput civis
stty -echo
# set -x
VERSION='6.1'

#tput cup 30 0
#echo -n "${ESC}s"
#echo "X=${X}; Y=${Y}"
#echo "ORIENT=${ORIENT}"
#echo "${COLOR}${SET}${RESET}"
#read
#echo -n "${ESC}u"
#echo "${ESC}0J"

#COMPUTER[16]="TARGET"
#COMPUTER[36]="TARGET"
#COMPUTER[56]='TARGET'
#COMPUTER[76]='TARGET'
#COMPUTER[17]='TARGET'
#COMPUTER[37]='TARGET'
#COMPUTER[18]='TARGET'
#COMPUTER[38]='TARGET'
#COMPUTER[58]='TARGET'
#COMPUTER[78]='TARGET'
#COMPUTER[98]='TARGET'
#COMPUTER[108]='TARGET'
#COMPUTER[110]='TARGET'
#COMPUTER[210]='TARGET'
#COMPUTER[310]='TARGET'
#COMPUTER[410]='TARGET'
#COMPUTER[610]='TARGET'
#COMPUTER[710]='TARGET'
#COMPUTER[910]='TARGET'
#COMPUTER[1010]='TARGET'

#┌─┬┐
#│ ││
#├─┼┤
#└─┴┘
#╓─╥╖
#║ ║║
#╟─╫╢
#╙─╨╜
#╒═╤╕
#│ ││
#╞═╪╡
#╘═╧╛
#╔═╦╗
#║ ║║
#╠═╬╣
#╚═╩╝

#█

#¤

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_SET_DEFAULT_SYSTEM_VAR () {    # Установка системных переменных
  ESC=$(echo -en "\E[")         # ESC-последовательность
  RESET=$(echo -en "\E[0m")     # Сброс форматирования вывода
  RED=$(echo -en "\E[1;31m")    # Красный цвет текста
  GREEN=$(echo -en "\E[1;32m")  # Зелёный цвет текста
  YELLOW=$(echo -en "\E[1;33m") # Желтый цвет текста
  BLUE=$(echo -en "\E[1;36m")   # Голубой цвет текста
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_ANSWER_USER () {                                                                            # Запрос к пользователю на начало или продолжение игры
  START=''                                                                                   # Сброс ответа пользователя
  while [ "${START}" != 'y' -a "${START}" != 'Y' -a "${START}" != 'n' -a "${START}" != 'N' ] # Пока ответ некорректный
    do                                                                                       # Делай
      case "$1" in                                                                           # Анализ вызова
        START)                                                                               # При старте
          TEXT='Начать игру? '                                                               # Подпись начала игры
          ;;                                                                                 # 
        MORE)                                                                                # При повторе
          TEXT='Повторить игру? '                                                            # Подпись повторения игры
          ;;                                                                                 # 
      esac                                                                                   # 
      _PRINT_MAIN                                                                            # Вывод заголовка программы
      echo -n "${TEXT}"                                                                      # Вывод сообщения пользователю
      tput cnorm                                                                             # Включение отображения курсора
      read -n1 START                                                                         # Чтение ответа пользователя
      echo                                                                                   # Перевод строки
      case "${START}" in                                                                     # Анализ решения пользователя (Стартуем?)
        n|N)                                                                                 # Нет
          tput civis                                                                         # Отключение отображения курсора
          return                                                                             # Выход из функции
          ;;                                                                                 # 
        y|Y)                                                                                 # Да
          ;;                                                                                 # 
        *)                                                                                   # Некорректный ответ
          echo 'Неверный ответ'                                                              # Уведомление пользователя
          sleep 1                                                                            # Задержка
      esac                                                                                   # 
      tput civis                                                                             # Отключение отображения курсора
    done                                                                                     # 
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_SET_DEFAULT_PROGRAM_VAR () {  # Сброс программных переменных
  START=''                     # Переменная для начала или повторения игры
  LIVE_COMPUTER=20             # "Жизни" компьютера
  LIVE_HUMAN=20                # "Жизни" игрока
  FIRE_HUMAN=0                 # Количество атакованных клеток на поле игрока
  FIRE_COMPUTER=0              # Количество атакованных клеток на поле компьютера
  ACCURACY_HUMAN=0             # Меткость игрока
  ACCURACY_COMPUTER=0          # Меткость компьютера
  HUMAN[4]=1
  HUMAN[3]=2
  HUMAN[2]=3
  HUMAN[1]=4
  COMPUTER[4]=1
  COMPUTER[3]=2
  COMPUTER[2]=3
  COMPUTER[1]=4
  Y_START=5                    # Номер строки, которую последней атаковал игрок
  X_START=5                    # Номер ячейки, которую последней атаковал игрок
  for ((Y=1;Y<=10;Y++))        # Цикл перебора строк поля
    do                         # делай
      for ((X=1;X<=10;X++))    # Цикл перебора ячеек поля в строке
        do                     # делай
          COMPUTER[${X}${Y}]=0 # Массив статусов ячеек поля компьютера
          HUMAN[${X}${Y}]=0    # Массив статусов ячеек поля игрока
        done                   # 
    done                       #
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_PRINT_FIELD () {                                                                                                                                          # Отрисовка игрового поля
  clear                                                                                                                                                    # Очистка экрана
  echo '┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ ┌──────────────────┬───────────────────────┬────────┬───────┐' # Откроем поле
  echo '│   │   │   │   │   │   │   │   │   │   │ │   │   │   │   │   │   │   │   │   │   │ │Монитор статистики│        "Жизни"        │Меткость│Корабли│' # Первая строка
  echo '├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├──────────────────┼────────────────────┬──┼────────┼─┬─┬─┬─┤' # Разделитель строк
  echo '│   │   │   │   │   │   │   │   │   │   │ │   │   │   │   │   │   │   │   │   │   │ │       Игрок      │                    │  │        │ │ │ │ │' # Вторая строка
  echo '├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├──────────────────┼────────────────────┼──┼────────┼─┼─┼─┼─┤' # Разделитель строк
  echo '│   │   │   │   │   │   │   │   │   │   │ │   │   │   │   │   │   │   │   │   │   │ │     Компьютер    │                    │  │        │ │ │ │ │' # Третья строка
  echo '├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ └──────────────────┴────────────────────┴──┴────────┴─┴─┴─┴─┘' # Разделитель строк
  echo '│   │   │   │   │   │   │   │   │   │   │ │   │   │   │   │   │   │   │   │   │   │'                                                               # Четвёртая строка
  echo '├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤'                                                               # Разделитель строк
  echo '│   │   │   │   │   │   │   │   │   │   │ │   │   │   │   │   │   │   │   │   │   │'                                                               # Пятая строка
  echo '├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤'                                                               # Разделитель строк
  echo '│   │   │   │   │   │   │   │   │   │   │ │   │   │   │   │   │   │   │   │   │   │'                                                               # Шестая строка
  echo '├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤'                                                               # Разделитель строк
  echo '│   │   │   │   │   │   │   │   │   │   │ │   │   │   │   │   │   │   │   │   │   │'                                                               # Седьмая строка
  echo '├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤'                                                               # Разделитель строк
  echo '│   │   │   │   │   │   │   │   │   │   │ │   │   │   │   │   │   │   │   │   │   │'                                                               # Восьмая строка
  echo '├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤'                                                               # Разделитель строк
  echo '│   │   │   │   │   │   │   │   │   │   │ │   │   │   │   │   │   │   │   │   │   │'                                                               # Девятая строка
  echo '├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤'                                                               # Разделитель строк
  echo '│   │   │   │   │   │   │   │   │   │   │ │   │   │   │   │   │   │   │   │   │   │'                                                               # Десятая строка
  echo '└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘'                                                               # Закроем поле
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_SET_SHIPS () {                                     # Установка кораблей
  TARGET="$1"                                       # Запомним поле для установки
  for ((COUNT=1;COUNT<=10;COUNT++))                 # Цикл установки 10 кораблей
    do                                              # делай
      case ${COUNT} in                              # Определение длины корабля
        1)LENGHT=4;;                                # Один четырёх-палубник
        2|3)LENGHT=3;;                              # Два трёх-палубника
        4|5|6)LENGHT=2;;                            # Три двух-палубкина
        *)LENGHT=1;;                                # Четыре одно-палубника
      esac                                          # 
      case ${TARGET} in                             # Определим того, кто расставляет корабли
        COMPUTER)                                   # Компьютер
          SET=1                                     # Сброс признака установки корабля
          while [ "${SET}" = 1 ]                    # Пока корабль не установлен
            do                                      # Делай
              ORIENT=${RANDOM}                      # Выбор случайного числа
              let "ORIENT %= 2"                     # Сокращение пределов
              case "${ORIENT}" in                   # Выбор ориентации корабля
                0)                                  # Если случайное число - 0
                  ORIENT='HORIZONTAL'               # Горизонтальная ориентация корабля
                  X_MAX=$(echo "11-${LENGHT}" | bc) # Определение максимальной ячейки начала корабля
                  Y_MAX=10                          # Определение максимальной строки начала корабля
                  ;;                                # 
                1)                                  # Если случайное число - 1
                  ORIENT='VERTICAL'                 # Вертикальная ориентация корабля
                  X_MAX=10                          # Определение максимальной ячейки начала корабля
                  Y_MAX=$(echo "11-${LENGHT}" | bc) # Определение максимальной строки начала корабля
                  ;;                                # 
              esac                                  # 
              X=${RANDOM}                           # Выбор случайной ячейки
              Y=${RANDOM}                           # Выбор случайной строки
              let "X %= ${X_MAX}"                   # Сокращение пределов
              let "Y %= ${Y_MAX}"                   # Сокращение пределов
              ((X++))                               # Корректировка номера ячейки
              ((Y++))                               # Корректировка номера строки
              _CONTROL_FIELD                        # Корректировка поля ограничений на установку корабля
              _IDENTIFY_COLOR                       # Определение возможности установки корабля в данном месте
              _SET_SHIP                             # Установка корабля в данном месте
              SET=$(echo $?)                        # Проверка установки корабля
            done                                    # 
          ;;                                        # 
        HUMAN)                                      # Игрок
          Y=5                                       # Выбираем 5 строку
          X=5                                       # Выбираем 5 ячейку
          ORIENT='HORIZONTAL'                       # Выбираем горизонтальную ориентацию корабля
          KEY=0                                     # Сброс кода клавиши
          CX_MIN=-1                                 # По умолчанию поле ограничений начинается на один столбец влево
          CX_MAX=${LENGHT}                          # По умолчанию поле ограничений заканчивается через длину корабля
          CY_MIN=-1                                 # По умолчанию поле ограничений начинается на одну строку выше
          CY_MAX=1                                  # По умолчанию поле ограничений заканчивается на одну строку ниже
          _IDENTIFY_COLOR                           # Определение возможности установки корабля в данном месте
          _PRINT_SHIP                               # Отрисовка корабля
          while [ "${KEY}" != '' ]                  # Пока корабль не на месте
            do                                      # Делай
              _READKEY                              # Запрос к пользователю
              _GO_SHIP                              # Движение корабля по полю
            done                                    # 
          ;;                                        # 
      esac                                          # 
    done                                            # 
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_GO_SHIP () {             # Перемещение корабля по полю
  case "${KEY}" in        # Анализ ответа пользователя (направления)
    A)                    # Вверх
      _CLEAR_SHIP         # Убрать отображение корабля
      ((Y--))             # Переместиться на строку вверх
      _CONTROL_FIELD      # Корректировка поля ограничений
      _IDENTIFY_COLOR     # Определение возможности установки корабля в данном месте
      _PRINT_SHIP         # Отрисовка корабля
      ;;                  # 
    B)                    # Вниз
      _CLEAR_SHIP         # Убрать отображение корабля
      ((Y++))             # Переместиться на строку вниз
      _CONTROL_FIELD      # Корректировка поля ограничений
      _IDENTIFY_COLOR     # Определение возможности расположения корабля в данном месте
      _PRINT_SHIP         # Отрисовка корабля
      ;;                  # 
    C)                    # Вправо
      _CLEAR_SHIP         # Убрать отображение корабля
      ((X++))             # Переместиться на ячейку вправо
      _CONTROL_FIELD      # Корректировка поля ограничений
      _IDENTIFY_COLOR     # Определение возможности расположения корабля в данном месте
      _PRINT_SHIP         # Отрисовка корабля
      ;;                  # 
    D)                    # Влево
      _CLEAR_SHIP         # Убрать отображение корабля
      ((X--))             # Переместиться на ячейку влево
      _CONTROL_FIELD      # Корректировка поля ограничений
      _IDENTIFY_COLOR     # Определение возможности установки корабля в данном месте
      _PRINT_SHIP         # Отрисовка корабля
      ;;                  # 
    F|4)                  # Нажата клавиша END
      read -n1            # Чтение "хвостов"
      _EXIT               # Завершение программы
      ;;                  # 
    5)                    # Нажата клавиша PAGE UP
      read -n1            # Чтение "хвостов"
      _CLEAR_SHIP         # Убрать отображение корабля
      ORIENT='VERTICAL'   # Смена ориентации корабля
      _CONTROL_FIELD      # Корректировка поля ограничений
      _IDENTIFY_COLOR     # Определение возможности установки корабля в данном месте
      _PRINT_SHIP         # Отрисовка корабля
      ;;                  # 
    6)                    # Нажата клавиша PAGE DOWN
      read -n1            # Чтение "хвостов"
      _CLEAR_SHIP         # Убрать отображение корабля
      ORIENT='HORIZONTAL' # Смена ориентации корабля
      _CONTROL_FIELD      # Корректировка поля ограничений
      _IDENTIFY_COLOR     # Определение возможности установка корабля в данном месте
      _PRINT_SHIP         # Отрисовка корабля
      ;;                  # 
    '')                   # Установка в данном месте
      _SET_SHIP           # Установка корабля
      ;;                  # 
  esac                    # 
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_CONTROL_FIELD () {                               # Корректировка поля ограничений
  case ${ORIENT} in                               # Анализ ориентации корабля
    HORIZONTAL)                                   # Горизонтальная
      if [ $Y -le 1 ]                             # Если корабль выше игрового поля или на его верхнем краю
        then                                      # то
          Y=1                                     # переместить корабль на верхнюю границу игрокого поля
          CY_MIN=0                                # Корректировка верхней границы поля ограничений
          CY_MAX=1                                # Корректировка нижней границы поля ограничений
      elif [ ${Y} -ge 10 ]                        # Если корабль ниже игрового поля или на его нижнем краю
        then                                      # то
          Y=10                                    # Переместить корабль на нижнюю границу игрового поля
          CY_MIN=-1                               # Корректировка верхней границы поля ограничений
          CY_MAX=0                                # Корректировка нижней границы поля ограничений
        else                                      # Иначе (корабль в поле)
          CY_MIN=-1                               # Корректировка верхней границы поля ограничений
          CY_MAX=1                                # Корректировка нижней границы поля ограничений
      fi                                          # 
      if [ $X -le 1 ]                             # Если корабль левее игрового поля или на его левом краю
        then                                      # то
          X=1                                     # Переместить корабль на левую границу игрового поля
          CX_MIN=0                                # Корректировка левой границы поля ограничений
          CX_MAX=${LENGHT}                        # Корректировка правой границы поля ограничений
      elif [ $X -ge $(echo "11-${LENGHT}" | bc) ] # Если корабль правее игрового поля или на его правом краю
        then                                      # то
          X=$(echo "11-${LENGHT}" | bc)           # Переместить корабль на правую границу игрового поля
          CX_MIN=-1                               # Корректировка левой границы поля ограничений
          CX_MAX=$(echo "${LENGHT}-1" | bc)       # Корректировка правой границы поля ограничений
        else                                      # Инача (корабль в поле)
          CX_MIN=-1                               # Корректировка левой границы поля ограничений
          CX_MAX=${LENGHT}                        # Корректировка правой граничцы поля ограничений
      fi                                          # 
      ;;                                          # 
    VERTICAL)                                     # Вертикальная
      if [ $Y -le 1 ]                             # Если корабль выше игрового поля или на его верхнем краю
        then                                      # то
          Y=1                                     # переместить корабль на верхнюю границу игрокого поля
          CY_MIN=0                                # Корректировка верхней границы поля ограничений
          CY_MAX=${LENGHT}                        # Корректировка нижней границы поля ограничений
      elif [ $Y -ge $(echo "11-${LENGHT}" | bc) ] # Если корабль ниже игрового поля или на его нижнем краю
        then                                      # то
          Y=$(echo "11-${LENGHT}" | bc)           # Переместить корабль на нижнюю границу игрового поля
          CY_MIN=-1                               # Корректировка верхней границы поля ограничений
          CY_MAX=$(echo "${LENGHT}-1" | bc)       # Корректировка нижней границы поля ограничений
        else                                      # Иначе (корабль в поле)
          CY_MIN=-1                               # Корректировка верхней границы поля ограничений
          CY_MAX=${LENGHT}                        # Корректировка нижней границы поля ограничений
      fi                                          #
      if [ $X -le 1 ]                             # Если корабль левее игрового поля или на его левом краю
        then                                      # то
          X=1                                     # Переместить корабль на левую границу игрового поля
          CX_MIN=0                                # Корректировка левой границы поля ограничений
          CX_MAX=1                                # Корректировка правой границы поля ограничений
      elif [ $X -ge 10 ]                          # Если корабль правее игрового поля или на его правом краю
        then                                      # то
          X=10                                    # Переместить корабль на правую границу игрового поля
          CX_MIN=-1                               # Корректировка левой границы поля ограничений
          CX_MAX=0                                # Корректировка правой границы поля ограничений
        else                                      # Инача (корабль в поле)
          CX_MIN=-1                               # Корректировка левой границы поля ограничений
          CX_MAX=1                                # Корректировка правой граничцы поля ограничений
      fi                                          #
      ;;                                          # 
  esac                                            # 
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_CLEAR_SHIP () {                        # Очистка отображения корабля
  case "${ORIENT}" in                   # Анализ ориентации корабля
    HORIZONTAL)                         # Горизонтальная
      ((X--))                           # Корректировка ячейки
      ;;                                # 
    VERTICAL)                           # Вертикальная
      ((Y--))                           # Корректировка строки
      ;;                                # 
    esac                                # 
  for ((C=0;C<${LENGHT};C++))           # Цикл перебора ячеек, занимаемых кораблём
    do                                  # делай
      case "${ORIENT}" in               # Анализ ориентации корабля
        HORIZONTAL)                     # Горизонтальная
          ((X++))                       # Переход к следующей ячейке
          ;;                            # 
        VERTICAL)                       # Вертикальная
          ((Y++))                       # Переход к следующей строке
          ;;                            # 
        esac                            # 
      _PRINT_STATUS                     # Отображение статуса ячейки
    done                                # 
  case "${ORIENT}" in                   # Анализ ориентации корабля
    HORIZONTAL)                         # Горизонтальная
      X=$(echo "${X}-${LENGHT}+1" | bc) # Возврат в начальную ячейку
      ;;                                # 
    VERTICAL)                           # Вертикальная
      Y=$(echo "${Y}-${LENGHT}+1" | bc) # Возврат в начальную строку
      ;;                                # 
  esac                                  # 
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_SET_SHIP () {                          # Установка корабля
  if [ "${COLOR}" = "${RED}" ]          # Если ставить сюда нельзя
    then                                # то
      KEY=0                             # Сброс кода клавиши
      return 1                          # Выход из функции с кодом ошибки
  fi                                    # 
  case "${ORIENT}" in                   # Анализ ориентации корабля
    HORIZONTAL)                         # Горизонтальная
      ((X--))                           # Корректировка ячейки
      ;;                                # 
    VERTICAL)                           # Вертикальная
      ((Y--))                           # Корректировка строки
      ;;                                # 
  esac                                  # 
  for ((C=0;C<${LENGHT};C++))           # Цикл перебора ячеек, занимаемых кораблём
    do                                  # делай
      case "${ORIENT}" in               # Анализ ориентации корабля
        HORIZONTAL)                     # Горизонтальная
          ((X++))                       # Переход к следующей ячейке
          ;;                            # 
        VERTICAL)                       # Вертикальная
          ((Y++))                       # Переход к следующей строке
          ;;                            # 
      esac                              # 
      case ${TARGET} in                 # Анализ поля установки
        HUMAN)                          # Поле игрока
          HUMAN[${X}${Y}]='SHIP'        # Смена статуса ячейки
          _PRINT_STATUS                 # Отображение статуса ячейки
          ;;                            # 
        COMPUTER)                       # Поле компьютера
          COMPUTER[${X}${Y}]='TARGET'   # Смена статуса ячейки
          ;;                            # 
      esac                              # 
    done                                # 
  case "${ORIENT}" in                   # Анализ ориентации корабля
    HORIZONTAL)                         # Горизонтальная
      X=$(echo "${X}-${LENGHT}+1" | bc) # Возврат в начальную ячейку
      ;;                                # 
    VERTICAL)                           # Вертикальная
      Y=$(echo "${Y}-${LENGHT}+1" | bc) # Возврат в начальную строку
      ;;                                # 
  esac                                  # 
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_PRINT_SHIP () {                        # Отображение корабля
  Y_SCOPE=$(echo "-1+2*${Y}" | bc)      # Высчитаем координату строки
  X_SCOPE=$(echo "-3+4*${X}" | bc)      # Высчитаем координату ячейки
  tput cup ${Y_SCOPE} ${X_SCOPE}        # Поместим курсор в ячейку
  echo -n "${COLOR}"                    # Включим цвет текста
  for ((C=1;C<=${LENGHT};C++))          # Цикл отображения судна
    do                                  # делай
      case "${ORIENT}" in               # Анализ ориентации корабля
        HORIZONTAL)                     # Горизонтальная
          echo -n "███${ESC}1C"         # Отображение судна в данной ячейке и смещение к следующей
          ;;                            # 
        VERTICAL)                       # Вертикальная
          echo -n "███${ESC}2B${ESC}3D" # Отображение судна в данной ячейке, смещение на строку вниз в начало ячейки
          ;;                            # 
      esac                              # 
    done                                # 
  echo "${RESET}"                       # Сброс цвета текста
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_IDENTIFY_COLOR () {                                                           # Определение возможности установки корабля в данном месте
  COLOR="${GREEN}"                                                             # По умолчанию - можно
  for ((CX=${CX_MIN};CX<=${CX_MAX};CX++))                                      # Цикл просмотра статусов ячеек в строках
    do                                                                         # Делай
      X_SCOPE=$(echo "${X}+${CX}" | bc)                                        # Определение ячейки
      for ((CY=${CY_MIN};CY<=${CY_MAX};CY++))                                  # Цикл просмотра строк
        do                                                                     # делай
          Y_SCOPE=$(echo "${Y}+${CY}" | bc)                                    # Определение строки
          case ${TARGET} in                                                    # Анализ поля установки
            HUMAN)                                                             # Поле игрока
              STATUS=${HUMAN[${X_SCOPE}${Y_SCOPE}]}                            # Запомним статус ячейки
              ;;                                                               # 
            COMPUTER)                                                          # Поле компьютера
              STATUS=${COMPUTER[${X_SCOPE}${Y_SCOPE}]}                         # Запомним статус ячейки
              ;;                                                               # 
          esac                                                                 # 
          [ "${STATUS}" = 'SHIP' -o "${STATUS}" = 'TARGET' ] && COLOR="${RED}" # Если хоть одна ячейка занята - то ставить корабль в данном месте нельзя
        done                                                                   # 
    done                                                                       # 
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_FIRE () {                                                        # Стрельба по сопернику
  TARGET="$1"                                                     # Запомним, по кому стреляем
  STATUS=''                                                       # Сброс статуса стрельбы
  while [ "${STATUS}" != 'MISS' ]                                 # Пока статус не "промах"
    do                                                            # делай
      [ ${LIVE_COMPUTER} -eq 0 -o ${LIVE_HUMAN} -eq 0 ] && return # Мёртвых не добиваем
      _AIMING                                                     # Целимся в цель
      _ATACK                                                      # Атакуем цель
    done                                                          # Конец стрельбы
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_AIMING () {                   # Прицеливание
  case ${TARGET} in            # Смотрим, кого атакуем
    COMPUTER)                  # Компьютера
      Y=${Y_START}             # Выберем 5 строку
      X=${X_START}             # Выберем 5 ячейку
      _PRINT_SCOPE             # Отобразим прицел
      KEY=0                    # Сброс кода клавиши
      while [ "${KEY}" != '' ] # Пока игрок не определился с ячейкой
        do                     # делай
          _READKEY             # Читай клавишу
          _GO_SCOPE            # Двигай прицел
        done                   # Конец определения ячейки
      X_START=${X}             # Запомним номер последней атакованной ячейки
      Y_START=${Y}             # Запомним номер последней атаковааной строки
      ;;                       # 
    HUMAN)                     # Игрока
      Y=${RANDOM}              # Выбор случайной строки
      X=${RANDOM}              # Выбор случайной ячейки
      let "Y %= 10"            # Ограничение пределов выбора строки
      let "X %= 10"            # Ограничение пределов выбора ячейки
      ((Y++))                  # Корректировка номера строки
      ((X++))                  # Корректировка номера ячейки
      ;;                       # 
  esac                         # 
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_PRINT_SCOPE () {                          # Отображение прицела
  Y_SCOPE=$(echo "-1+2*${Y}" | bc)         # Высчитаем координату У
  case ${TARGET} in                        # Определяем цель
    COMPUTER)                              # Компьютер
      X_SCOPE=39                           # Берём поле компьютера
      ;;                                   # 
    HUMAN)                                 # Игрок
      X_SCOPE=-3                           # Берём поле игрока
      ;;                                   # 
  esac                                     # 
  X_SCOPE=$(echo "${X_SCOPE}+4*${X}" | bc) # Высчитаем координату Х
  tput cup ${Y_SCOPE} ${X_SCOPE}           # Поместим курсор в ячейку
  echo "${YELLOW}>¤<${RESET}"              # Отобразим "прицел"
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_READKEY () {                     # Пользовательский интерфейс
  read -n3 KEY                    # Чтение кода клавиши
  KEY=$(echo "${KEY}" | cut -c 3) # Запомним контрольный символ
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_GO_SCOPE () {                # Двигаем прицел
  case "${KEY}" in            # Анализ кода клавиши
    A)                        # Стрелка вверх
      _PRINT_STATUS           # Отображение статуса ячейки
      ((Y--))                 # Смещение на строку вверх
      [ ${Y} -le 0 ] && Y=1   # Контроль границ поля
      _PRINT_SCOPE            # Отображение новой позиции прицела
      ;;                      # 
    B)                        # Стрелка вниз
      _PRINT_STATUS           # Отображение статуса ячейки
      ((Y++))                 # Смещение на строку вниз
      [ ${Y} -ge 11 ] && Y=10 # Контроль границ поля
      _PRINT_SCOPE            # Отображение новой позиции прицела
      ;;                      # 
    D)                        # Стрелка влево
      _PRINT_STATUS           # Отображение статуса ячейки
      ((X--))                 # Смещение на ячейку влево
      [ ${X} -le 0 ] && X=1   # Контроль границ поля
      _PRINT_SCOPE            # Отображение новой позиции прицела
      ;;                      # 
    C)                        # Стрелка вправо
      _PRINT_STATUS           # Отображение статуса ячейки
      ((X++))                 # Смещение на ячейку вправо
      [ ${X} -ge 11 ] && X=10 # Контроль границ поля
      _PRINT_SCOPE            # Отображение новой позиции прицела
      ;;                      # 
    4)                        # Клавиша END
      read -n1                # Отбрасывание "хвостов"
      _EXIT                   # Завершение программы
      ;;                      # 
    '')                       # Ентер
      _PRINT_STATUS           # Отображение статуса ячейки
  esac                        # Конец анализа
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_PRINT_STATUS () {                         # Отрисовка статуса ячейки
  case ${TARGET} in                        # Определим цель
    COMPUTER)                              # Компьютер
      STATUS=${COMPUTER[${X}${Y}]}         # Запомним статус ячейки
      X_SCOPE=39                           # Выберем поле компьютера
      ;;                                   # 
    HUMAN)                                 # Игрок
      STATUS=${HUMAN[${X}${Y}]}            # Запомним статус ячейки
      X_SCOPE=-3                           # Выберем поле игрока
      ;;                                   # 
  esac                                     # 
  Y_SCOPE=$(echo "-1+2*${Y}" | bc)         # Высчитаем координату Y
  X_SCOPE=$(echo "${X_SCOPE}+4*${X}" | bc) # Высчитаем координату X
  tput cup ${Y_SCOPE} ${X_SCOPE}           # Поместим курсор в ячейку
  case "${STATUS}" in                      # Анализ статуса
    SHIP)                                  # Корабль (игрока)
      echo '███'                           # Отобразим его
      ;;                                   # 
    TARGET)                                # Цель (корабль компьютера)
      echo '   '                           # Скроем его
      ;;                                   # 
    MISS)                                  # Промах
      echo "${BLUE}~~~${RESET}"            # Типа море
      ;;                                   # 
    CONTACT)                               # Подбит
      echo "${RED}███${RESET}"             # Типа пожар
      ;;                                   # 
    DEAD)                                  # Потоплен
      echo "${BLUE}███${RESET}"            # Типа утонувший корабль
      ;;                                   # 
    NOT)                                   # Пустая клетка
#      echo "${GREEN}***${RESET}"
      ;;                                   # 
    *)                                     # Прочие (пусто или "закрыто")
      echo '   '                           # Пусто...
      ;;                                   # 
  esac                                     # Конец анализа
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_ATACK () {                                                                         # Атака
  case ${TARGET} in                                                                 # Определяем цель
    COMPUTER)                                                                       # Компьютер
      STATUS=${COMPUTER[${X}${Y}]}                                                  # Запомним статус ячейки
      ;;                                                                            # 
    HUMAN)                                                                          # Игрок
      STATUS=${HUMAN[${X}${Y}]}                                                     # Запомним статус ячейки
      ;;                                                                            # 
  esac                                                                              # 
  case "${STATUS}" in                                                               # Анализ статуса ячейки
    TARGET)                                                                         # Цель (корабль компьютера)
      ((LIVE_COMPUTER--))                                                           # Уменьшение "жизней" компьютера
      STATUS='CONTACT'                                                              # Смена статуса
      ;;                                                                            # 
    SHIP)                                                                           # Корабль (игрока)
      ((LIVE_HUMAN--))                                                              # Уменьшение "жизней" игрока
      STATUS='CONTACT'                                                              # Смена статуса
      ;;                                                                            # 
    MISS|CONTACT|DEAD|NOT)                                                          # Промах, подбит, потоплен (ячейка уже обстреливалась) или пустая
      STATUS=''                                                                     # Смена статуса
      return                                                                        # Завершение неудачной атаки
      ;;                                                                            # 
    *)                                                                              # Прочие (пусто, "закрытая")
      STATUS='MISS'                                                                 # Смена статуса
      ;;                                                                            # 
  esac                                                                              # Конец анализа статуса ячейки
  case ${TARGET} in                                                                 # Определяем цель
    COMPUTER)                                                                       # Компьютер
      ((FIRE_COMPUTER++))                                                           # Увеличение количества атакованных клеток на поле компьютера
      ACCURACY_HUMAN=$(echo "scale=2; (20-${LIVE_COMPUTER})/${FIRE_COMPUTER}" | bc) # Подсчёт меткости игрока
      ACCURACY_HUMAN=$(echo "scale=0; ${ACCURACY_HUMAN}*100/1" | bc)                # Перевод в проценты
      COMPUTER[${X}${Y}]=${STATUS}                                                  # Смена статуса ячейки
      ;;                                                                            # 
    HUMAN)                                                                          # Игрок
      ((FIRE_HUMAN++))                                                              # Увеличение атакованных клеток на поле игрока
      ACCURACY_COMPUTER=$(echo "scale=2; (20-${LIVE_HUMAN})/${FIRE_HUMAN}" | bc)    # Подсчёт меткости компьютера
      ACCURACY_COMPUTER=$(echo "scale=0; ${ACCURACY_COMPUTER}*100/1" | bc)          # Перевод в проценты
      HUMAN[${X}${Y}]=${STATUS}                                                     # Смена статуса ячейки
      ;;                                                                            # 
  esac                                                                              # 
  _PRINT_STATUS                                                                     # Отображение нового статуса ячейки
  [ "${STATUS}" = 'CONTACT' ] && _ANALISE_SHIP                                      # Если есть попадание, то необходимо проверить корабль на "плавучесть"
  _PRINT_LIVE                                                                       # Вывод статистики
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_ANALISE_SHIP () {                                                                     # Анализ корабля на "плавучесть"
  DEAD='YES'                                                                           # По умолчанию корабль потоплен
  UP=0                                                                                 # Сброс количества клеток, занимаемых кораблём вверх от точки попадания
  DOWN=0                                                                               # Сброс количества клеток, занимаемых кораблём вниз от точки попадания
  LEFT=0                                                                               # Сброс количества клеток, занимаемых кораблём влево от точки попадания
  RIGHT=0                                                                              # Сброс количества клеток, занимаемых кораблём вправо от точки попадания
  C=0                                                                                  # Сброс смещения
  Y_SCOPE=${Y}                                                                         # Смотрим вверх, начиная с точки попадания
  while [ "${STATUS}" = 'CONTACT' -a ${Y_SCOPE} -ne 0 ]                                # Пока статус = Подбит и мы не вышли за пределы поля
    do                                                                                 # делай
      case "${TARGET}" in                                                              # Анализ цели
        COMPUTER)                                                                      # Компьютер
          STATUS=${COMPUTER[${X}${Y_SCOPE}]}                                           # Получение статуса ячейки
          ;;                                                                           # 
        HUMAN)                                                                         # Игрок
          STATUS=${HUMAN[${X}${Y_SCOPE}]}                                              # Получение статуса ячейки
          ;;                                                                           # 
      esac                                                                             # 
      [ "${STATUS}" = 'TARGET' -o "${STATUS}" = 'SHIP' ] && DEAD='NO'                  # Если статус = корабль или цель, то судно не потоплено
      [ "${STATUS}" = 'CONTACT' ] && UP=${C}                                           # Если статус = подбит, то запомним количество ячеек, занимаемых кораблём вверх от точки попадания
      ((C++))                                                                          # Увеличиваем смещение
      Y_SCOPE=$(echo "${Y}-${C}" | bc)                                                 # Смещаемся выше
    done                                                                               # 
  C=1                                                                                  # Сброс смещения на 1 клетку
  Y_SCOPE=$(echo "${Y}+${C}" | bc)                                                     # Смотрим вниз
  STATUS='CONTACT'                                                                     # Сброс статуса
  while [ "${STATUS}" = 'CONTACT' -a ${Y_SCOPE} -ne 11 ]                               # Пока статус = подбит и мы не вышли за пределы поля
    do                                                                                 # делай
      case "${TARGET}" in                                                              # Анализ цели
        COMPUTER)                                                                      # Компьютер
          STATUS=${COMPUTER[${X}${Y_SCOPE}]}                                           # Получение статуса ячейки
          ;;                                                                           # 
        HUMAN)                                                                         # Игрок
          STATUS=${HUMAN[${X}${Y_SCOPE}]}                                              # Получение статуса ячейки
          ;;                                                                           # 
      esac                                                                             # 
      [ "${STATUS}" = 'TARGET' -o "${STATUS}" = 'SHIP' ] && DEAD='NO'                  # Если статус = цель или корабль, то судно не потоплено
      [ "${STATUS}" = 'CONTACT' ] && DOWN=${C}                                         # Если статус = подбит, то запомним количество ячеек, занимаемых судном вниз от точки попадания
      ((C++))                                                                          # Увеличиваем смещение
      Y_SCOPE=$(echo "${Y}+${C}" | bc)                                                 # Смещаемся вниз
    done                                                                               # 
  C=1                                                                                  # Сброс смещения на 1 клетку
  X_SCOPE=$(echo "${X}-${C}" | bc)                                                     # Смотрим влево
  STATUS='CONTACT'                                                                     # Сброс статуса
  while [ "${STATUS}" = 'CONTACT' -a ${X_SCOPE} -ne 0 ]                                # Пока статус = подбит и мы не вышли за пределы поля
    do                                                                                 # делай
      case "${TARGET}" in                                                              # Анализ цели
        COMPUTER)                                                                      # Компьютер
          STATUS=${COMPUTER[${X_SCOPE}${Y}]}                                           # Запомним статус ячейки
          ;;                                                                           # 
        HUMAN)                                                                         # Игрок
          STATUS=${HUMAN[${X_SCOPE}${Y}]}                                              # Запомним статус ячейки
          ;;                                                                           # 
      esac                                                                             # 
      [ "${STATUS}" = 'TARGET' -o "${STATUS}" = 'SHIP' ] && DEAD='NO'                  # Если статус = цель или корабль, то судно не потоплено
      [ "${STATUS}" = 'CONTACT' ] && LEFT=${C}                                         # Если статус = подбит, то запомним количество ячеек, занимаемых кораблём влево от точки попадания
      ((C++))                                                                          # Увеличиваем смещение
      X_SCOPE=$(echo "${X}-${C}" | bc)                                                 # Смещаемся влево
    done                                                                               # 
  C=1                                                                                  # Сброс смещения на 1 клетку
  X_SCOPE=$(echo "${X}+${C}" | bc)                                                     # Смотрим вправо
  STATUS='CONTACT'                                                                     # Сброс статуса
  while [ "${STATUS}" = 'CONTACT' -a ${X_SCOPE} -ne 11 ]                               # Пока статус = подбит и мы не вышли за пределы поля
    do                                                                                 # делай
      case "${TARGET}" in                                                              # Анализ цели
        COMPUTER)                                                                      # Компьютер
          STATUS=${COMPUTER[${X_SCOPE}${Y}]}                                           # Запомним статус ячейки
          ;;                                                                           # 
        HUMAN)                                                                         # Игрок
          STATUS=${HUMAN[${X_SCOPE}${Y}]}                                              # Запомним статус ячейки
          ;;                                                                           # 
      esac                                                                             # 
      [ "${STATUS}" = 'TARGET' -o "${STATUS}" = 'SHIP' ] && DEAD='NO'                  # Если статус = цель или корабль, то судно не потоплено
      [ "${STATUS}" = 'CONTACT' ] && RIGHT=${C}                                        # Если статус = подбит, то запомним количество ячеек, занимаемых кораблём вправо от точки попадания
      ((C++))                                                                          # Увеличиваем смещение
      X_SCOPE=$(echo "${X}+${C}" | bc)                                                 # Смещаемся вправо
    done                                                                               # 
  if [ "${DEAD}" = 'YES' ]                                                             # Если корабль потоплен
    then                                                                               # то
      LENGHT=$(echo "${LEFT}+${RIGHT}+2" | bc)                                         # Запомним длину ореола корабля
      HEIGHT=$(echo "${UP}+${DOWN}+2" | bc)                                            # Запомним высоту ореола корабля
      SHIP=$(echo "${UP}+${RIGHT}+${DOWN}+${LEFT}+1" | bc)
case "${TARGET}" in
  COMPUTER)
    ((COMPUTER[${SHIP}]--))
    ;;
  HUMAN)
    ((HUMAN[${SHIP}]--))
    ;;
esac
      X_SCALE=${X}                                                                     # Запомним номер ячейки
      Y_SCALE=${Y}                                                                     # Запомним номер строки
      X=$(echo "${X}-${LEFT}-1" | bc)                                                  # Переместимся в левую ячейку ореола корабля
      Y=$(echo "${Y}-${UP}-1" | bc)                                                    # Переместимся в верхнюю строку ореола корабля
      ((X<1)) && X=1 && ((LENGHT--))                                                   # Проверка нахождения левой границы ореола корабля в поле
      ((Y<1)) && Y=1 && ((HEIGHT--))                                                   # Проверка нахождения верхней границы ореола корабля в поле
      ((X+LENGHT>10)) && ((LENGHT--))                                                  # Проверка нахождения правой границы ореола корабля в поле
      ((Y+HEIGHT>10)) && ((HEIGHT--))                                                  # Проверка нахождения нижней границы ореола корабля в поле
      for ((H=0;H<=HEIGHT;H++))                                                        # Цикл просмотра строк ореола корабля
        do                                                                             # делай
          Y=$(echo "${Y}+${H}" | bc)                                                   # Перемещение по строкам
          for ((L=0;L<=LENGHT;L++))                                                    # Цикл просмотра ячеек в строке ореола корабля
            do                                                                         # делай
              X=$(echo "${X}+${L}" | bc)                                               # Перемещение по ячейкам
              case "${TARGET}" in                                                      # Анализ цели
                COMPUTER)                                                              # Компьютер
                  [ "${COMPUTER[${X}${Y}]}" = 'CONTACT' ] && COMPUTER[${X}${Y}]='DEAD' # Если в ячейке был подбитый корабль, то сменить статус на "Потоплен"
                  ;;                                                                   # 
                HUMAN)                                                                 # Игрок
                  [ "${HUMAN[${X}${Y}]}" != 'CONTACT' ] && HUMAN[${X}${Y}]='NOT'       # Если в ячейке был не корабль, то она пуста
                  [ "${HUMAN[${X}${Y}]}" = 'CONTACT' ] && HUMAN[${X}${Y}]='DEAD'       # Если в ячейке был корабль, то он потоплен
                  ;;                                                                   # 
              esac                                                                     # 
              _PRINT_STATUS                                                            # Отображение нового статуса ячейки
              X=$(echo "${X}-${L}" | bc)                                               # Возврат в левую ячейку ореола корабля
            done                                                                       # 
          Y=$(echo "${Y}-${H}" | bc)                                                   # Возврат в верхнюю строку ореола корабля
        done                                                                           # 
      X=${X_SCALE}                                                                     # Возврат в атакованную ячейку
      Y=${Y_SCALE}                                                                     # Возврат в атакованную строку
  fi                                                                                   # 
  STATUS='CONTACT'                                                                     # Сброс статуса
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_VICTORY () {                                                                     # Обьявление победителя
  [ ${LIVE_COMPUTER} -eq 0 ] && TEXT='Игрок'                                      # Если у компьютера не осталось жизней, то выиграл игрок
  if [ ${LIVE_HUMAN} -eq 0 ]                                                      # Если проиграл игрок
    then                                                                          # то
      TARGET='COMPUTER'                                                           # Цель - компьютер
      TEXT='Компьютер'                                                            # Подпись победителя
      for ((Y=1;Y<=10;Y++))                                                       # Цикл перебора строк
        do                                                                        # делай
          for ((X=1;X<=10;X++))                                                   # Цикл перебора ячеек
            do                                                                    # делай
              [ "${COMPUTER[${X}${Y}]}" = 'TARGET' ] && COMPUTER[${X}${Y}]='SHIP' # Замена статусов "цель" на "корабль"
              _PRINT_STATUS                                                       # Отображение статуса ячейки
            done                                                                  # 
        done                                                                      # 
  fi                                                                              # 
  tput cnorm                                                                      # Включение отображения курсора
  tput cup 30 0                                                                   # Уберем курсор вниз
  echo 'Игра окончена!!!'                                                         # Объявление окончания игры
  echo '------------------'                                                       # Разделитель
  echo "${TEXT} выиграл!"                                                         # Объявление победителя
  _READ_ENTER                                                                     # Ожидание нажатия ENTER
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_EXIT () {   # Выход из программы
  clear      # Очистка экрана
  stty echo  # Включение вывода сообщений на экран
  tput cnorm # Отображение курсора
  exit       # Выход
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_PRINT_LIVE () {                                                    # Вывод статистики
  tput cup 3 104                                                    # Поместим курсор в нужную позицию
  echo -n "${GREEN}"                                                # Включение зелёного цвета текста
  for ((COUNT=1;COUNT<=${LIVE_HUMAN};COUNT++))                      # Цикл отображения полосы состояния "жизней" игрока
    do                                                              # делай
      echo -n "■"                                                   # Наращивание полосы
    done                                                            # 
  for ((COUNT=1;COUNT<=$(echo "20-${LIVE_HUMAN}" | bc);COUNT++))    # Цикл дополнения полосы состояния "жизней" игрока
    do                                                              # делай
      echo -n ' '                                                   # Дополнение полосы
    done                                                            # 
  tput cup 3 125                                                    # Поместим курсор в нужную позицию
  [ ${LIVE_HUMAN} -lt 10 ] && echo -n ' '                           # Корректировка старшего разряда
  echo -n "${LIVE_HUMAN}"                                           # Вывод количества "жизней" игрока
  tput cup 3 129                                                    # Поместим курсор в нужную позицию
  [ ${ACCURACY_HUMAN} -lt 100 ] && echo -n ' '                      # Корректировка разряда сотен
  [ ${ACCURACY_HUMAN} -lt 10 ] && echo -n ' '                       # Корректировка разряда десяток
  echo -n "${ACCURACY_HUMAN} %"                                     # Вывод меткости игрока
  tput cup 3 137
  echo -n "${HUMAN[4]}${ESC}1C${HUMAN[3]}${ESC}1C${HUMAN[2]}${ESC}1C${HUMAN[1]}"

  tput cup 5 104                                                    # Перемещение курсора в нужную позицию
  echo -n "${RED}"                                                  # Включение красного цвета текста
  for ((COUNT=1;COUNT<=${LIVE_COMPUTER};COUNT++))                   # Цикл отображения полосы состояния "жизней" компьютера
    do                                                              # делай
      echo -n "■"                                                   # Наращивание полосы
    done                                                            # 
  for ((COUNT=1;COUNT<=$(echo "20-${LIVE_COMPUTER}" | bc);COUNT++)) # Цикл дополнения полосы состояния "жизней" компьютера
    do                                                              # делай
      echo -n ' '                                                   # Дополнение полосы
    done                                                            # 
  tput cup 5 125                                                    # Поместим курсор в нужную позицию
  [ ${LIVE_COMPUTER} -lt 10 ] && echo -n ' '                        # Корректировка старшего разряда
  echo -n "${LIVE_COMPUTER}"                                        # Вывод количества "жизней" компьютера
  tput cup 5 129                                                    # Поместим курсор в нужную позицию
  [ ${ACCURACY_COMPUTER} -lt 100 ] && echo -n ' '                   # Корректировка разряда сотен
  [ ${ACCURACY_COMPUTER} -lt 10 ] && echo -n ' '                    # Корректировка разряда десяток
  echo -n "${ACCURACY_COMPUTER} %"                                  # Вывод меткости компьютера
  tput cup 5 137
  echo -n "${COMPUTER[4]}${ESC}1C${COMPUTER[3]}${ESC}1C${COMPUTER[2]}${ESC}1C${COMPUTER[1]}"
  echo "${RESET}"                                                   # Сброс форматирования вывода
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_PRINT_MENU () {                        # Отображение меню
  _PRINT_MAIN                           # Вывод заголовка программы
  tput sc                               # Запомним позицию курсора
  echo '--> 1. Начать игру'             # Вывод пункта меню "Начать игру" и стрелки выбора пункта
  echo '    2. Справка'                 # Вывод пункта меню "Справка"
  echo '    3. История'                 # Вывод пункта меню "История"
  echo '    4. Планы'                   # Вывод пункта меню "Планы"
  echo '    0. Выход'                   # Вывод пункта меню "Выход"
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_GO_MENU () {           # Передвижение по меню
  case "${KEY}" in      # Анализ нажатой клавиши
    B)                  # Стрелка вниз
      tput rc           # Восстановим положение курсора
      echo '   '        # "Сотрём" стрелку выбора пункта меню и перейдём на следующую строку
      tput sc           # Запомним положение курсора
      ((Y++))           # Увеличим номер выбранного пункта
      if [ ${Y} -gt 5 ] # Если номер пункта больше, чем их количество
        then            # то
          Y=1           # Выбираем пункт 1
          tput cup 2 0  # Переместим к нему курсор
          tput sc       # Запомним положение курсора
      fi                # 
      echo '-->'        # Отобразим стрелку выбора пункта меню
      ;;                # 
    A)                  # Стрелка вверх
      tput rc           # Восстановим положение курсора
      echo '   '        # "Сотрём" стрелку выбора пункта меню
      tput rc           # Восстановим положение курсора
      echo "${ESC}2A"   # Переместим курсор на 1 строку выше
      tput sc           # Запомним положение курсора
      ((Y--))           # Уменьшим номер выбранного пункта
      if [ ${Y} -lt 1 ] # Если номер пункта меньше 1
        then            # то
          Y=5           # Выбираем последний пункт
          tput cup 6 0  # Переместим к нему курсор
          tput sc       # Запомним положение курсора
      fi                # 
      echo '-->'        # Отобразим стрелку выбора пункта меню
      ;;                # 
  esac                  # 
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_MENU () {                 # Работа с меню
  _PRINT_MENU              # Отобразим меню
  Y=1                      # Выбираем 1 пункт
  KEY=1                    # Сброс нажатой клавиши
  while [ "${KEY}" != '' ] # Пока пользователь не определился с пунктом меню
    do                     # делай
      _READKEY             # Чтение клавиши
      _GO_MENU             # Передвижение по меню
    done                   # 
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_HISTORY () { # История программы
  _PRINT_MAIN # Вывод заголовка программы
  echo '
Версия Изменения
1.0    "Тупая пальба"
2.0    Добавление запроса к пользователю на запуск игры
2.2    Реакция на клавишу END
       Основа логики игры
2.3    Отображение курсора при запросе пользователя
       Добавление объявления победителя
       Убран переход прицела на другую сторону поля
3.0    Добавлена ручная расстановка кораблей игрока
3.3    Добавлена возможность смены ориентации кораблей
4.0    Добавлена автоматическая расстановка кораблей компьютера
4.1    Убран возврат корабля игрока в центр при смене ориентации
       Добавлен монитор статистики
       Добавлено отображение кораблей компьютера при проигрыше игрока
4.2    Добавлено стартовое меню
       Добавлен пункт меню "Начало игры"
       Добавлен пункт меню "Справка"
4.4    Добавление пункта меню - История
       Исправление ошибок в Справке
       Добавлено запоминание последней атакованной игроком клетки
4.5    Добавление пункта меню "Планы"
       Оптимизация действий в меню
5.0    Добавлен статус "Потоплен"
       Отредактирована Справка
5.1    Изменение монитора статистики
       Оптимизация логики отображения монитора статистики
6.0    Оптимизация логики анализа "потопленности" корабля
       Улучшение ИИ (запоминание "ореолов" кораблей)
6.1    Дополнение монитора статистики'
  _READ_ENTER # Ожидание нажатия ENTER
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_PLANS () {   # Планы дальнейшего развития
  _PRINT_MAIN # Вывод заголовка программы
  echo 'Планы:

1. Улучшение ИИ
2. Портирование на ЯВУ
3. Добавление мультимедиа
4. Добавление настроек игры
5. Оптимизация программы'
  _READ_ENTER # Ожидание нажатия ENTER
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_DOING () {              # Действия в меню
  case ${Y} in           # Анализ выбранного пункта
    1)                   # Начать игру
      _ANSWER_USER START # Получение подтверждения
      ;;                 # 
    2)                   # Справка
      _MAN               # Вывод справки по программе
      ;;                 # 
    3)                   # История
      _HISTORY           # Вывод истории развития программы
      ;;                 # 
    4)                   # Планы
      _PLANS             # Вывод планов дальнейшего развития программы
      ;;                 # 
    5)                   # Выход
      return             # Выход из функции
      ;;                 # 
  esac                   # 
  Y=1                    # Сброс номера выбранного пункта меню
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_MAN () {                               # Справка по программе
  _PRINT_MAIN                           # Вывод заголовка программы
  echo 'Справка: '                      # Вывод справки
  echo "
${YELLOW}Морской бой${RESET} - игра для двух участников, в которой игроки по очереди называют координаты на неизвестной им карте соперника. 
Если у соперника по этим координатам имеется корабль (координаты заняты), то корабль или его часть топится, а попавший получает право сделать ещё один ход. 
Цель игрока - первым поразить все корабли противника.

${YELLOW}Расположение кораблей:${RESET}
Игровое поле - квадраты 10x10 для каждого игрока, на которых размещается флот кораблей.

Размещаются:
  1 корабль - ряд из 4 клеток (линкоры или четырёхпалубные)
  2 корабля - ряд из 3 клеток (крейсеры или трёхпалубные)
  3 корабля - ряд из 2 клеток (эсминцы или двухпалубные)
  4 корабля - 1 клетка (подлодки или однопалубные)

При размещении корабли не могут касаться друг друга углами или сторонами.
Рядом со своим полем чертится чужое такого же размера, только пустое. Это участок моря, где плавают корабли противника.
При попадании в корабль противника - это отмечается на чужом поле. Попавший стреляет ещё раз.

${YELLOW}Поиск и потопление кораблей противника:${RESET}
1. Если выстрел пришёлся в клетку, не занятую ни одним кораблём противника, то следует ответ ${BLUE}~~~${RESET}, и стрелявший игрок отмечает это на чужом поле. Право хода переходит к сопернику.
2. Если выстрел пришёлся в клетку, где находится многопалубный корабль (размером больше, чем 1 клетка), то следует ответ ${RED}███${RESET}, кроме одного случая (см. пункт 3). 
   Стрелявший игрок отмечает это на чужом поле и получает право на ещё один выстрел.
3. Если выстрел пришёлся в клетку, где находится однопалубный корабль или последнюю непоражённую клетку многопалубного корабля, то следует ответ ${BLUE}███${RESET}.
   Стрелявший игрок отмечает это на чужом поле и получает право на ещё один выстрел.

Победителем считается тот, кто первым потопит все 10 кораблей противника. Проигравший имеет право попросить изучить после окончания игры у соперника игровое поле. 

${YELLOW}Легенда:${RESET}
${GREEN}███${RESET}                            - В данном месте поля можно расположить корабль
${RED}███${RESET} (при расстановке кораблей) - В данном месте поля нельзя располагать корабль
${RED}███${RESET} (при игре)                 - Попадание в корабль
███                            - В данном месте расположен корабль
${BLUE}███${RESET}                            - Корабль потоплен
${BLUE}~~~${RESET}                            - Промах
${YELLOW}>¤<${RESET}                            - Прицел

${YELLOW}Управление:${RESET}
Стрелки   - Передвижение корабля при расстановке, перемещение прицела при игре
PAGE UP   - Повернуть корабль вертикально (при расстановке)
PAGE DOWN - Повернуть корабль горизонтально (при расстановке)
ENTER     - Принять (установить корабль или атаковать клетку)
END       - Завершение работы программы"
  _READ_ENTER # Ожидание нажатия ENTER
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_PRINT_MAIN () {                        # Вывод заголовка программы
  clear                                 # Очистка экрана
  echo "Морской бой! Версия ${VERSION}" # Вывод заголовка
  echo '-----------------------'        # Вывод разделителя
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_READ_ENTER () {                       # Ожидание нажатия ENTER
  echo                                 # Вывод пустой строки
  echo 'Для продолжения нажмите ENTER' # Вывод сообщения пользователю
  read                                 # Ожидание нажатия ENTER
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_SET_DEFAULT_SYSTEM_VAR                                         # Установка стартовых значений системных переменных
Y=1                                                             # Сброс номера выбранного пункта меню
while [ ${Y} -ne 5 ]                                            # Пока пользователь не выбрал "Выход"
  do                                                            # делай
    _MENU                                                       # Выбор пункта меню
    _DOING                                                      # Действие в соответствии с выбранным пунктом
    while [ "${START}" = 'y' -o "${START}" = 'Y' ]              # Пока ответ на подтверждение запкска игры "Да"
      do                                                        # делай
        _SET_DEFAULT_PROGRAM_VAR                                # Установка стартовых значений программных переменных
        _PRINT_FIELD                                            # Отрисовка игрового поля
        _SET_SHIPS HUMAN                                        # Расстановка кораблей игрока
        _SET_SHIPS COMPUTER                                     # Расстановка кораблей компьютера
        while [ ${LIVE_COMPUTER} -ne 0 -a ${LIVE_HUMAN} -ne 0 ] # Пока у одного из соперников не кончились "жизни"
          do                                                    # делай
            _PRINT_LIVE                                         # Вывод статистики
            _FIRE COMPUTER                                      # Стреляем по компьютеру
            _FIRE HUMAN                                         # Стреляем по игроку
          done                                                  # Конец цикла ("жизни" у кого-то закончились)
        _VICTORY                                                # Объявление победителя
        _ANSWER_USER MORE                                       # Запрос к пользователю на повторение игры
      done                                                      # Конец цикла (пользователь не хочет запускать игру ещё раз)
  done                                                          # 
_EXIT                                                           # Корректный выход
